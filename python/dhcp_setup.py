#!/usr/bin/env python

import os
import subprocess
import sys
import signal
import time

import ipaddr

import westspec

##############################################

def check_call(*args, **kwargs):
    """Like subprocess.check_call, but also logs command to stderr"""
    command = ' '.join(args[0]) if isinstance(args[0], list) else args[0]
    sys.stderr.write('%s\n' % command)
    return subprocess.check_call(*args, **kwargs)

class DhcpSetup(object):
    """Create DHCP Configuration and apply to DHCPd if necessary

       Supposed to run in the RFC1918/Private namespace"""

    def __init__(self, base_if, restart):
        self.base_if = base_if
        self.restart = restart
        self.customers = [c for c in westspec.customers if c.privnet is not None]
        self.configfile = '/tmp/dhcpd-private.conf'
        self.pidfile = '/run/dhcpd-private.pid'
        self.leasefile = '/var/lib/dhcp/dhcpd-private.leases'

    # Helper functions
    def iface(self, vid):
        """Creates interface name from VLAN id"""
        return '%s.%d' % (self.base_if, vid)

    @classmethod
    def vid(cls, iface):
        """Gets VLAN id from interface name"""
        return int(iface.split('.')[-1])

    def get_customer_config(self, customer, acc_config, acc_interfaces):
        """Get config for all subnet"""
        network = customer.privnet
        new_config = acc_config + '\n'
        new_interfaces = acc_interfaces

        if not network.hasrtrip('cluster'):
            new_config += '# Ignoring customer VLAN %d\n' % customer.vid
            new_config += "# as we don't seem to have an IP there\n"
            return (new_config, new_interfaces)

        ip_network = ipaddr.IPNetwork(network.ip)
        new_config += '# DHCP subnet for VLAN %d\n' % customer.vid
        new_config += 'subnet %s netmask %s {\n' % (ip_network.network, ip_network.netmask)
        new_config += '    range %s %s;\n' % (ip_network.network + 16, ip_network.broadcast - 16)
        new_config += '    option routers %s;\n' % network.rtrip['cluster']
        new_config += '    option broadcast-address %s;\n' % ip_network.broadcast
        new_config += '}\n'

        new_interfaces += [self.iface(customer.vid)]
        return (new_config, new_interfaces)

    def get_config(self):
        """Return a tuple containing a dhcpd config and a list
           of interfaces to run dhcp on."""
        acc_config = ''
        acc_interfaces = []

        acc_config += '# Autogenerated config created by %s\n' % os.path.abspath(__file__)
        acc_config += 'ddns-update-style none;\n'
        acc_config += 'option domain-name "%s";\n' % os.getenv('DHCP_DOMAIN_NAME')
        dns_servers = os.getenv('DHCP_DNS_SERVERS').split()
        acc_config += 'option domain-name-servers %s;\n' % (', '.join(dns_servers))
        acc_config += 'option netbios-node-type 1;\n'
        acc_config += 'default-lease-time 3600;\n'
        acc_config += 'max-lease-time 14400;\n'
        acc_config += 'authoritative;\n'

        for c in self.customers:
            (acc_config, acc_interfaces) = self.get_customer_config(c, acc_config, acc_interfaces)

        return (acc_config, sorted(acc_interfaces))

    def update_config(self, new_config):
        """Update the dhcp server config if necessary. Return True if
           config changed and false otherwise"""

        if os.path.exists(self.configfile):
            with open(self.configfile, 'r') as cf:
                old_config = cf.read()
        else:
            old_config = ''

        if old_config == new_config:
            return False

        with open(self.configfile, 'w') as cf:
            cf.write(new_config)
        return True

    def dhcpd_pid(self):
        """Returns pid of dhcpd or False
           if not running"""
        if not os.path.exists(self.pidfile):
            return False
        with open(self.pidfile, 'r') as pf:
            pid = int(pf.read().strip())
        if not os.path.exists('/proc/%d/cmdline' % pid):
            return False
        return pid

    def dhcpd_status(self):
        """Returns a list of interfaces for which dhcpd is active
           or False if dhcpd is not running"""
        pid = self.dhcpd_pid()
        if pid is False:
            return False

        with open('/proc/%s/cmdline' % pid, 'r') as cmdline_file:
            cmdline = cmdline_file.read()

        interfaces = []
        for arg in cmdline.split('\x00'):
            if arg.startswith(self.base_if):
                interfaces.append(arg)

        return sorted(interfaces)

    def stop_dhcpd(self):
        """Stops dhcpd if it is running"""
        pid = self.dhcpd_pid()
        if pid is False:
            print >>sys.stderr, "STRANGE: dhcpd is not running"
            return

        print >>sys.stderr, "Sending SIGTERM do dhcpd"
        os.kill(pid, signal.SIGTERM)
        print >>sys.stderr, "Waiting for dhcpd to stop"
        for _ in range(15):
            if self.dhcpd_pid() is False:
                print >>sys.stderr, "dhcpd stopped"
                break
            time.sleep(1)
        else:
            print >>sys.stderr, "dhcpd did not stop, sending sigkill"
            os.kill(pid, signal.SIGKILL)
            time.sleep(5)
            if self.dhcpd_pid() is not False:
                raise RuntimeError("DHCPD did not stop")

    def start_dhcpd(self, interfaces):
        """Starts dhcpd for the given interfaces. Care should be taken that
           dhcpd is not already running.
           Also, given dhcpds command line syntax, an empty interface list
           will result in dhcpd considering all interfaces."""
        args = ['/usr/sbin/dhcpd', '-q',
                '-cf', self.configfile,
                '-pf', self.pidfile,
                '-lf', self.leasefile]
        args += interfaces
        check_call(args)

    def configure(self):
        """Make sure that dhcpd runs according to the given configuration"""
        configuration, interfaces = self.get_config()

        config_changed = self.update_config(configuration)
        dhcpd_status = self.dhcpd_status()

        if config_changed or dhcpd_status != interfaces or self.restart:
            if dhcpd_status is not False:
                self.stop_dhcpd()
            self.start_dhcpd(interfaces)

##############################################

parser = westspec.setup('DHCP Setup')
parser.add_argument('--restart', action='store_true')
parser.add_argument('--iface', required=True,
                    help="Which interface the customer vlans are on")

spec, script_args = westspec.load(parser)

##############################################

DhcpSetup(script_args.iface, script_args.restart).configure()
